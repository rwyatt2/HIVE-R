#!/usr/bin/env node
/**
 * HIVE-R Design Token Exporter
 * 
 * Export design tokens to any format for use in any project.
 * 
 * Usage:
 *   npx ts-node scripts/export-tokens.ts [options]
 * 
 * Options:
 *   --tokens <path>    Path to tokens JSON file (default: design-systems/tokens.example.json)
 *   --output <dir>     Output directory (default: ./design-system-export)
 *   --format <format>  Output format: all, css, tailwind, scss, json (default: all)
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
import { join, resolve, dirname } from "path";
import { fileURLToPath } from "url";

// ESM-compatible __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface Tokens {
    meta?: { name?: string; version?: string };
    colors?: Record<string, unknown>;
    typography?: Record<string, unknown>;
    spacing?: Record<string, unknown>;
    borders?: Record<string, unknown>;
    shadows?: Record<string, unknown>;
    effects?: Record<string, unknown>;
    layout?: Record<string, unknown>;
    animation?: Record<string, unknown>;
    [key: string]: unknown;
}

// Parse CLI args
const args = process.argv.slice(2);
const getArg = (name: string, defaultVal: string): string => {
    const idx = args.indexOf(`--${name}`);
    return idx !== -1 && args[idx + 1] ? args[idx + 1] : defaultVal;
};

const tokensPath = resolve(getArg("tokens", "design-systems/tokens.example.json"));
const outputDir = resolve(getArg("output", "./design-system-export"));
const format = getArg("format", "all");

console.log(`\nüé® HIVE-R Design Token Exporter\n`);
console.log(`   Tokens: ${tokensPath}`);
console.log(`   Output: ${outputDir}`);
console.log(`   Format: ${format}\n`);

// Load tokens
if (!existsSync(tokensPath)) {
    console.error(`‚ùå Tokens file not found: ${tokensPath}`);
    process.exit(1);
}

const tokens: Tokens = JSON.parse(readFileSync(tokensPath, "utf-8"));

// Create output directory
if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
}

// Flatten nested objects to CSS variable format
function flattenToCSSVars(obj: Record<string, unknown>, prefix = ""): Record<string, string> {
    const result: Record<string, string> = {};

    for (const [key, value] of Object.entries(obj)) {
        const varName = prefix ? `${prefix}-${key}` : key;

        if (value && typeof value === "object" && !Array.isArray(value)) {
            if ("value" in value && typeof value.value === "string") {
                result[varName] = value.value;
            } else {
                Object.assign(result, flattenToCSSVars(value as Record<string, unknown>, varName));
            }
        } else if (typeof value === "string" || typeof value === "number") {
            result[varName] = String(value);
        }
    }

    return result;
}

// Generate CSS custom properties
function generateCSS(tokens: Tokens): string {
    const lines: string[] = [
        "/**",
        ` * ${tokens.meta?.name || "Design System"} - CSS Custom Properties`,
        ` * Generated by HIVE-R Token Exporter`,
        ` * Version: ${tokens.meta?.version || "1.0.0"}`,
        " */",
        "",
        ":root {"
    ];

    // Colors
    if (tokens.colors) {
        lines.push("  /* Colors */");
        const colorVars = flattenToCSSVars(tokens.colors, "color");
        for (const [name, value] of Object.entries(colorVars)) {
            lines.push(`  --${name}: ${value};`);
        }
        lines.push("");
    }

    // Typography
    if (tokens.typography) {
        lines.push("  /* Typography */");
        const typoVars = flattenToCSSVars(tokens.typography, "font");
        for (const [name, value] of Object.entries(typoVars)) {
            lines.push(`  --${name}: ${value};`);
        }
        lines.push("");
    }

    // Spacing
    if (tokens.spacing?.scale) {
        lines.push("  /* Spacing */");
        const spacing = tokens.spacing.scale as Record<string, string>;
        for (const [name, value] of Object.entries(spacing)) {
            lines.push(`  --space-${name}: ${value};`);
        }
        lines.push("");
    }

    // Borders
    if (tokens.borders?.radius) {
        lines.push("  /* Border Radius */");
        const radii = tokens.borders.radius as Record<string, string>;
        for (const [name, value] of Object.entries(radii)) {
            lines.push(`  --radius-${name}: ${value};`);
        }
        lines.push("");
    }

    // Shadows
    if (tokens.shadows) {
        lines.push("  /* Shadows */");
        for (const [name, value] of Object.entries(tokens.shadows)) {
            if (typeof value === "string") {
                lines.push(`  --shadow-${name}: ${value};`);
            }
        }
        lines.push("");
    }

    // Animation
    if (tokens.animation) {
        lines.push("  /* Animation */");
        if (tokens.animation.duration) {
            for (const [name, value] of Object.entries(tokens.animation.duration as Record<string, string>)) {
                lines.push(`  --duration-${name}: ${value};`);
            }
        }
        if (tokens.animation.easing) {
            for (const [name, value] of Object.entries(tokens.animation.easing as Record<string, string>)) {
                lines.push(`  --ease-${name}: ${value};`);
            }
        }
        lines.push("");
    }

    lines.push("}");

    // Dark mode
    if (tokens.colors?.dark) {
        lines.push("");
        lines.push(".dark, [data-theme='dark'] {");
        const darkVars = flattenToCSSVars(tokens.colors.dark as Record<string, unknown>, "color");
        for (const [name, value] of Object.entries(darkVars)) {
            lines.push(`  --${name}: ${value};`);
        }
        lines.push("}");

        lines.push("");
        lines.push("@media (prefers-color-scheme: dark) {");
        lines.push("  :root:not(.light) {");
        for (const [name, value] of Object.entries(darkVars)) {
            lines.push(`    --${name}: ${value};`);
        }
        lines.push("  }");
        lines.push("}");
    }

    return lines.join("\n");
}

// Generate Tailwind config
function generateTailwindConfig(tokens: Tokens): string {
    const config: Record<string, unknown> = {
        theme: {
            extend: {}
        }
    };

    const extend = config.theme.extend as Record<string, unknown>;

    // Colors - flatten primitives
    if (tokens.colors?.primitives) {
        extend.colors = tokens.colors.primitives;
    }

    // Font family
    if (tokens.typography?.fontFamily) {
        extend.fontFamily = {};
        for (const [name, value] of Object.entries(tokens.typography.fontFamily as Record<string, string>)) {
            (extend.fontFamily as Record<string, string[]>)[name] = [value];
        }
    }

    // Font size
    if (tokens.typography?.fontSize) {
        extend.fontSize = {};
        for (const [name, value] of Object.entries(tokens.typography.fontSize as Record<string, { value: string; lineHeight?: string }>)) {
            if (typeof value === "object" && value.value) {
                (extend.fontSize as Record<string, [string, { lineHeight?: string }]>)[name] = [
                    value.value,
                    { lineHeight: value.lineHeight }
                ];
            }
        }
    }

    // Spacing
    if (tokens.spacing?.scale) {
        extend.spacing = tokens.spacing.scale;
    }

    // Border radius
    if (tokens.borders?.radius) {
        extend.borderRadius = tokens.borders.radius;
    }

    // Shadows
    if (tokens.shadows) {
        extend.boxShadow = {};
        for (const [name, value] of Object.entries(tokens.shadows)) {
            if (typeof value === "string") {
                (extend.boxShadow as Record<string, string>)[name] = value;
            }
        }
    }

    // Z-index
    if (tokens.layout?.zIndex) {
        extend.zIndex = tokens.layout.zIndex;
    }

    return `/** @type {import('tailwindcss').Config} */
module.exports = ${JSON.stringify(config, null, 2)}`;
}

// Generate SCSS variables
function generateSCSS(tokens: Tokens): string {
    const lines: string[] = [
        "//",
        `// ${tokens.meta?.name || "Design System"} - SCSS Variables`,
        "// Generated by HIVE-R Token Exporter",
        "//",
        ""
    ];

    // Colors
    if (tokens.colors?.primitives) {
        lines.push("// Colors");
        const colorVars = flattenToCSSVars(tokens.colors.primitives as Record<string, unknown>, "color");
        for (const [name, value] of Object.entries(colorVars)) {
            lines.push(`$${name}: ${value};`);
        }
        lines.push("");
    }

    // Spacing
    if (tokens.spacing?.scale) {
        lines.push("// Spacing");
        const spacing = tokens.spacing.scale as Record<string, string>;
        for (const [name, value] of Object.entries(spacing)) {
            lines.push(`$space-${name}: ${value};`);
        }
        lines.push("");
    }

    // Border radius
    if (tokens.borders?.radius) {
        lines.push("// Border Radius");
        const radii = tokens.borders.radius as Record<string, string>;
        for (const [name, value] of Object.entries(radii)) {
            lines.push(`$radius-${name}: ${value};`);
        }
        lines.push("");
    }

    return lines.join("\n");
}

// Export functions
const exports: Record<string, () => void> = {
    css: () => {
        const css = generateCSS(tokens);
        writeFileSync(join(outputDir, "tokens.css"), css);
        console.log("   ‚úì tokens.css");
    },
    tailwind: () => {
        const config = generateTailwindConfig(tokens);
        writeFileSync(join(outputDir, "tailwind.config.js"), config);
        console.log("   ‚úì tailwind.config.js");
    },
    scss: () => {
        const scss = generateSCSS(tokens);
        writeFileSync(join(outputDir, "_tokens.scss"), scss);
        console.log("   ‚úì _tokens.scss");
    },
    json: () => {
        writeFileSync(join(outputDir, "tokens.json"), JSON.stringify(tokens, null, 2));
        console.log("   ‚úì tokens.json");
    }
};

// Run exports
console.log("Generating files:");

if (format === "all") {
    Object.values(exports).forEach(fn => fn());
} else if (exports[format]) {
    exports[format]();
} else {
    console.error(`‚ùå Unknown format: ${format}`);
    process.exit(1);
}

// Also copy PRINCIPLES.md
const principlesPath = join(__dirname, "../design-systems/PRINCIPLES.md");
if (existsSync(principlesPath)) {
    const principles = readFileSync(principlesPath, "utf-8");
    writeFileSync(join(outputDir, "PRINCIPLES.md"), principles);
    console.log("   ‚úì PRINCIPLES.md");
}

console.log(`\n‚úÖ Export complete! Files saved to: ${outputDir}\n`);
console.log("Usage in your project:");
console.log("   CSS:      @import './design-system-export/tokens.css';");
console.log("   Tailwind: Copy tailwind.config.js to your project root");
console.log("   SCSS:     @use './design-system-export/tokens';");
console.log("");
