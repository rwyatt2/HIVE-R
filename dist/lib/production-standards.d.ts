/**
 * Production Code Standards
 *
 * Injected into all agents to ensure production-ready code generation.
 * These are non-negotiable standards for all generated code.
 */
export declare const PRODUCTION_CODE_STANDARDS = "\n## \uD83D\uDEA8 PRODUCTION CODE REQUIREMENTS (Non-Negotiable)\n\nYou are building PRODUCTION-READY code, not prototypes. Every line of code must be:\n\n### 1. Error Resilient\n- EVERY async call wrapped in try/catch with proper error handling\n- User-friendly error messages (never expose stack traces)\n- Graceful degradation when services fail\n- Retry logic for transient failures\n\n### 2. Type Safe\n- NO 'any' types - use proper TypeScript generics\n- Strict null checks - handle undefined cases\n- Validate all external inputs with Zod or similar\n- Define explicit return types\n\n### 3. Accessible (WCAG 2.1 AA)\n- Semantic HTML (proper heading hierarchy, landmarks)\n- ARIA labels on interactive elements\n- Keyboard navigable (focus management)\n- Color contrast \u2265 4.5:1 for text\n- Screen reader compatible\n\n### 4. Performant\n- Lazy load non-critical components\n- Optimize images (WebP, proper sizing)\n- Bundle size budget: < 200KB initial JS\n- No memory leaks (clean up effects/subscriptions)\n- Use React.memo/useMemo for expensive computations\n\n### 5. Secure\n- Validate and sanitize ALL user inputs\n- Use parameterized queries (no SQL injection)\n- Implement CSRF protection\n- Set secure HTTP headers (CSP, X-Frame-Options)\n- Never log sensitive data (passwords, tokens, PII)\n\n### 6. Tested\n- Unit tests for business logic (\u226580% coverage)\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n- Edge case coverage (empty states, errors)\n\n### 7. Observable\n- Structured logging with correlation IDs\n- Error tracking (Sentry, LogRocket, etc.)\n- Performance monitoring\n- Health check endpoints\n\n### 8. Maintainable\n- Self-documenting code (clear names, no magic numbers)\n- JSDoc for public APIs\n- README for setup/deployment\n- Changelog for breaking changes\n";
export declare const BUILDER_PRODUCTION_STANDARDS = "\n\n## \uD83D\uDEA8 PRODUCTION CODE REQUIREMENTS (Non-Negotiable)\n\nYou are building PRODUCTION-READY code, not prototypes. Every line of code must be:\n\n### 1. Error Resilient\n- EVERY async call wrapped in try/catch with proper error handling\n- User-friendly error messages (never expose stack traces)\n- Graceful degradation when services fail\n- Retry logic for transient failures\n\n### 2. Type Safe\n- NO 'any' types - use proper TypeScript generics\n- Strict null checks - handle undefined cases\n- Validate all external inputs with Zod or similar\n- Define explicit return types\n\n### 3. Accessible (WCAG 2.1 AA)\n- Semantic HTML (proper heading hierarchy, landmarks)\n- ARIA labels on interactive elements\n- Keyboard navigable (focus management)\n- Color contrast \u2265 4.5:1 for text\n- Screen reader compatible\n\n### 4. Performant\n- Lazy load non-critical components\n- Optimize images (WebP, proper sizing)\n- Bundle size budget: < 200KB initial JS\n- No memory leaks (clean up effects/subscriptions)\n- Use React.memo/useMemo for expensive computations\n\n### 5. Secure\n- Validate and sanitize ALL user inputs\n- Use parameterized queries (no SQL injection)\n- Implement CSRF protection\n- Set secure HTTP headers (CSP, X-Frame-Options)\n- Never log sensitive data (passwords, tokens, PII)\n\n### 6. Tested\n- Unit tests for business logic (\u226580% coverage)\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n- Edge case coverage (empty states, errors)\n\n### 7. Observable\n- Structured logging with correlation IDs\n- Error tracking (Sentry, LogRocket, etc.)\n- Performance monitoring\n- Health check endpoints\n\n### 8. Maintainable\n- Self-documenting code (clear names, no magic numbers)\n- JSDoc for public APIs\n- README for setup/deployment\n- Changelog for breaking changes\n\n\n## Builder-Specific Requirements\n\n### Code Structure\n- Follow existing project patterns (don't introduce new conventions)\n- Keep files under 300 lines (split if larger)\n- One component per file\n- Co-locate tests with components\n\n### Dependencies\n- Prefer built-in APIs over new dependencies\n- If adding a dependency, justify the bundle size cost\n- Check for security vulnerabilities before using\n\n### Performance Checklist\nBefore completing any component:\n- [ ] No console.logs in production code\n- [ ] Loading states for async operations\n- [ ] Error boundaries around risky components\n- [ ] Virtualization for large lists\n";
export declare const DESIGNER_PRODUCTION_STANDARDS = "\n\n## \uD83D\uDEA8 PRODUCTION CODE REQUIREMENTS (Non-Negotiable)\n\nYou are building PRODUCTION-READY code, not prototypes. Every line of code must be:\n\n### 1. Error Resilient\n- EVERY async call wrapped in try/catch with proper error handling\n- User-friendly error messages (never expose stack traces)\n- Graceful degradation when services fail\n- Retry logic for transient failures\n\n### 2. Type Safe\n- NO 'any' types - use proper TypeScript generics\n- Strict null checks - handle undefined cases\n- Validate all external inputs with Zod or similar\n- Define explicit return types\n\n### 3. Accessible (WCAG 2.1 AA)\n- Semantic HTML (proper heading hierarchy, landmarks)\n- ARIA labels on interactive elements\n- Keyboard navigable (focus management)\n- Color contrast \u2265 4.5:1 for text\n- Screen reader compatible\n\n### 4. Performant\n- Lazy load non-critical components\n- Optimize images (WebP, proper sizing)\n- Bundle size budget: < 200KB initial JS\n- No memory leaks (clean up effects/subscriptions)\n- Use React.memo/useMemo for expensive computations\n\n### 5. Secure\n- Validate and sanitize ALL user inputs\n- Use parameterized queries (no SQL injection)\n- Implement CSRF protection\n- Set secure HTTP headers (CSP, X-Frame-Options)\n- Never log sensitive data (passwords, tokens, PII)\n\n### 6. Tested\n- Unit tests for business logic (\u226580% coverage)\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n- Edge case coverage (empty states, errors)\n\n### 7. Observable\n- Structured logging with correlation IDs\n- Error tracking (Sentry, LogRocket, etc.)\n- Performance monitoring\n- Health check endpoints\n\n### 8. Maintainable\n- Self-documenting code (clear names, no magic numbers)\n- JSDoc for public APIs\n- README for setup/deployment\n- Changelog for breaking changes\n\n\n## Designer-Specific Requirements\n\n### Visual Standards\n- Mobile-first responsive design\n- Touch targets \u2265 44x44px\n- Loading skeletons (not spinners) for content\n- Smooth transitions (150-300ms)\n\n### Design System\n- Use design tokens, not hardcoded values\n- Support dark mode from day 1\n- Test on real devices, not just Chrome DevTools\n- Consider reduced motion preferences\n\n### Accessibility First\n- Design focus states before hover states\n- Ensure color is not the only indicator\n- Test with VoiceOver/NVDA\n";
export declare const REVIEWER_PRODUCTION_STANDARDS = "\n\n## \uD83D\uDEA8 PRODUCTION CODE REQUIREMENTS (Non-Negotiable)\n\nYou are building PRODUCTION-READY code, not prototypes. Every line of code must be:\n\n### 1. Error Resilient\n- EVERY async call wrapped in try/catch with proper error handling\n- User-friendly error messages (never expose stack traces)\n- Graceful degradation when services fail\n- Retry logic for transient failures\n\n### 2. Type Safe\n- NO 'any' types - use proper TypeScript generics\n- Strict null checks - handle undefined cases\n- Validate all external inputs with Zod or similar\n- Define explicit return types\n\n### 3. Accessible (WCAG 2.1 AA)\n- Semantic HTML (proper heading hierarchy, landmarks)\n- ARIA labels on interactive elements\n- Keyboard navigable (focus management)\n- Color contrast \u2265 4.5:1 for text\n- Screen reader compatible\n\n### 4. Performant\n- Lazy load non-critical components\n- Optimize images (WebP, proper sizing)\n- Bundle size budget: < 200KB initial JS\n- No memory leaks (clean up effects/subscriptions)\n- Use React.memo/useMemo for expensive computations\n\n### 5. Secure\n- Validate and sanitize ALL user inputs\n- Use parameterized queries (no SQL injection)\n- Implement CSRF protection\n- Set secure HTTP headers (CSP, X-Frame-Options)\n- Never log sensitive data (passwords, tokens, PII)\n\n### 6. Tested\n- Unit tests for business logic (\u226580% coverage)\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n- Edge case coverage (empty states, errors)\n\n### 7. Observable\n- Structured logging with correlation IDs\n- Error tracking (Sentry, LogRocket, etc.)\n- Performance monitoring\n- Health check endpoints\n\n### 8. Maintainable\n- Self-documenting code (clear names, no magic numbers)\n- JSDoc for public APIs\n- README for setup/deployment\n- Changelog for breaking changes\n\n\n## Code Review Checklist\n\n### Must Block (Critical)\n- [ ] Security vulnerabilities\n- [ ] Missing error handling\n- [ ] Breaking accessibility\n- [ ] Memory leaks\n- [ ] Missing input validation\n\n### Should Address (Important)\n- [ ] Missing tests\n- [ ] Poor performance\n- [ ] Inconsistent patterns\n- [ ] Missing TypeScript types\n\n### Consider (Nice to Have)\n- [ ] Code comments\n- [ ] Variable naming\n- [ ] File organization\n";
export declare const TESTER_PRODUCTION_STANDARDS = "\n\n## \uD83D\uDEA8 PRODUCTION CODE REQUIREMENTS (Non-Negotiable)\n\nYou are building PRODUCTION-READY code, not prototypes. Every line of code must be:\n\n### 1. Error Resilient\n- EVERY async call wrapped in try/catch with proper error handling\n- User-friendly error messages (never expose stack traces)\n- Graceful degradation when services fail\n- Retry logic for transient failures\n\n### 2. Type Safe\n- NO 'any' types - use proper TypeScript generics\n- Strict null checks - handle undefined cases\n- Validate all external inputs with Zod or similar\n- Define explicit return types\n\n### 3. Accessible (WCAG 2.1 AA)\n- Semantic HTML (proper heading hierarchy, landmarks)\n- ARIA labels on interactive elements\n- Keyboard navigable (focus management)\n- Color contrast \u2265 4.5:1 for text\n- Screen reader compatible\n\n### 4. Performant\n- Lazy load non-critical components\n- Optimize images (WebP, proper sizing)\n- Bundle size budget: < 200KB initial JS\n- No memory leaks (clean up effects/subscriptions)\n- Use React.memo/useMemo for expensive computations\n\n### 5. Secure\n- Validate and sanitize ALL user inputs\n- Use parameterized queries (no SQL injection)\n- Implement CSRF protection\n- Set secure HTTP headers (CSP, X-Frame-Options)\n- Never log sensitive data (passwords, tokens, PII)\n\n### 6. Tested\n- Unit tests for business logic (\u226580% coverage)\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n- Edge case coverage (empty states, errors)\n\n### 7. Observable\n- Structured logging with correlation IDs\n- Error tracking (Sentry, LogRocket, etc.)\n- Performance monitoring\n- Health check endpoints\n\n### 8. Maintainable\n- Self-documenting code (clear names, no magic numbers)\n- JSDoc for public APIs\n- README for setup/deployment\n- Changelog for breaking changes\n\n\n## Testing Requirements\n\n### Test Quality\n- Tests should be deterministic (no flaky tests)\n- Use meaningful assertions (not just \"toExist\")\n- Test behavior, not implementation\n- Mock external services, not internal modules\n\n### Coverage Targets\n- Business logic: \u226580%\n- API endpoints: 100%\n- Critical paths: E2E tests\n- Edge cases: Explicit tests\n\n### Test Structure\n- Arrange-Act-Assert pattern\n- One logical assertion per test\n- Descriptive test names that explain intent\n";
export declare const ROI_MINDSET = "\n## \uD83D\uDCB0 ROI-Focused Development\n\nEvery decision should consider:\n\n### Build vs Buy\n- Don't build what you can npm install (if maintained)\n- Don't npm install what takes 10 lines to write\n- Evaluate maintenance burden, not just initial effort\n\n### Technical Debt\n- No \"TODOs\" without linked tickets\n- Fix broken windows immediately\n- Refactor while context is fresh\n\n### Scalability\n- Would this survive 10,000 concurrent users?\n- What happens when data grows 100x?\n- How do we monitor this in production?\n\n### Operational Cost\n- Consider hosting costs (compute, bandwidth)\n- Consider developer time to maintain\n- Consider support burden (clear error messages reduce tickets)\n";
export declare function getStandardsForAgent(agentName: string): string;
//# sourceMappingURL=production-standards.d.ts.map